rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
  
    // Users can read their own data, System Admins can read all users
    match /users/{userId} {
      allow read, write: if request.auth != null && (
        request.auth.uid == userId ||
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role in ['admin', 'sra', 'system_admin']
      );
    }
    
    // ✅ Allow unauthenticated verification link to read and update
    match /users/{userId} {
      // Allow reading unverified users (needed for verify.html)
      allow read: if request.auth == null && resource.data.emailVerified == false;

      // Allow updating emailVerified → true and status → "verified"
      allow update: if
        request.auth == null &&
        request.resource.data.emailVerified == true &&
        resource.data.emailVerified == false &&
        request.resource.data.status == "verified";
    }

    // Allow creation of users for SRA Officer registration
    match /users/{userId} {
      allow create: if request.auth != null || 
        (request.resource.data.role == 'sra' && 
         request.resource.data.email != null && 
         request.resource.data.name != null);
    }

    
    // System Admin access to all collections for dashboard analytics
    match /{document=**} {
      allow read: if request.auth != null &&
        (exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
         get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'system_admin');
    }
    
    // Allow creation of notifications
    match /notifications/{notificationId} {
      allow read: if true;

      // Admins can do everything
      allow create, update, delete: if request.auth != null &&
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role in ['sra', 'admin', 'system_admin'];

      // Users can mark their own notifications as read
      allow update: if request.auth != null &&
        resource.data.userId == request.auth.uid &&
        request.resource.data.status == "read";
    }

    
    // Allow creation of email_queue
    match /email_queue/{emailId} {
      allow create, read, update, delete: if request.auth != null;
    }

    // Allow public submission of feedbacks; only system_admin can read/manage them
    match /feedbacks/{feedbackId} {
      // Allow anyone (even unauthenticated) to create feedback entries so users can send quick feedback.
      allow create: if true;

      // Only system_admin users can read, update or delete feedback entries
      allow read, update, delete: if request.auth != null &&
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'system_admin';
    }
    
    // Fields access rules
    match /fields/{fieldId} {
      // Anyone authenticated can read fields
      allow read: if request.auth != null;
      
      // Only verified landowners can create fields
      allow create: if request.auth != null && 
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'landowner' &&
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.status == 'verified';
      
      // Only the field owner can update their fields
      allow update: if request.auth != null && 
        resource.data.landowner_id == request.auth.uid;
      
      // Only the field owner can delete their fields
      allow delete: if request.auth != null && 
        resource.data.landowner_id == request.auth.uid;
    }
    
    // Add this block inside your firestore.rules, e.g. after the users or fields rules
    match /field_applications/{docId} {
      allow create: if request.auth != null;
      allow read: if request.auth != null;
      allow update: if request.auth != null && (
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'sra' ||
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin'
      );
    }
    
    // --- Nested field applications (for each user) ---
    match /field_applications/{uid}/fields/{fieldId} {
      allow read: if request.auth != null;  // allow SRA dashboard and users to read
      allow create: if request.auth != null && request.auth.uid == uid;
      allow update: if request.auth != null &&
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role in ['sra', 'admin'];
    }

    // Allow SRA/Admin to add remarks inside each field application
    match /field_applications/{uid}/fields/{fieldId}/remarks/{remarkId} {
      allow read: if request.auth != null && (
        request.auth.uid == uid ||
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role in ['sra', 'admin', 'system_admin']
      );

      allow create: if request.auth != null &&
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role in ['sra', 'admin'];
    }

    // --- Needed so collectionGroup('fields') queries can read anywhere ---
    match /{path=**}/fields/{fieldId} {
      allow read: if request.auth != null;  // allows nested reads for authenticated users
    }

    // Field workers (join requests) access rules
    match /field_workers/{requestId} {
      // Users can read their own requests
      allow read: if request.auth != null && 
        (resource.data.user_uid == request.auth.uid || 
         get(/databases/$(database)/documents/fields/$(resource.data.field_id)).data.landowner_id == request.auth.uid);
      
      // Users can create join requests for any field
      allow create: if request.auth != null && 
        request.resource.data.user_uid == request.auth.uid;
      
      // Only the field owner can update join requests (approve/reject)
      allow update: if request.auth != null && 
        get(/databases/$(database)/documents/fields/$(resource.data.field_id)).data.landowner_id == request.auth.uid;
      
      // Users can delete their own requests, field owners can delete requests for their fields
      allow delete: if request.auth != null && 
        (resource.data.user_uid == request.auth.uid || 
         get(/databases/$(database)/documents/fields/$(resource.data.field_id)).data.landowner_id == request.auth.uid);
    }
    
    // Task logs access rules
    match /task_logs/{logId} {
      // Field workers can read logs for fields they're approved to work on
      allow read: if request.auth != null && 
        (resource.data.user_uid == request.auth.uid || 
         get(/databases/$(database)/documents/fields/$(resource.data.field_id)).data.landowner_id == request.auth.uid);
      
      // Approved field workers can create task logs
      allow create: if request.auth != null && 
        request.resource.data.user_uid == request.auth.uid &&
        exists(/databases/$(database)/documents/field_workers/$(request.auth.uid + '_' + resource.data.field_id)) &&
        get(/databases/$(database)/documents/field_workers/$(request.auth.uid + '_' + resource.data.field_id)).data.status == 'approved';
      
      // Users can update their own task logs
      allow update: if request.auth != null && 
        resource.data.user_uid == request.auth.uid;
      
      // Users can delete their own task logs, field owners can delete logs for their fields
      allow delete: if request.auth != null && 
        (resource.data.user_uid == request.auth.uid || 
         get(/databases/$(database)/documents/fields/$(resource.data.field_id)).data.landowner_id == request.auth.uid);
    }
    
    // Reports access rules
    match /reports/{reportId} {
      // Field owners can read reports for their fields
      allow read: if request.auth != null && 
        get(/databases/$(database)/documents/fields/$(resource.data.field_id)).data.landowner_id == request.auth.uid;
      
      // Field owners can create reports for their fields
      allow create: if request.auth != null && 
        get(/databases/$(database)/documents/fields/$(request.resource.data.field_id)).data.landowner_id == request.auth.uid;
      
      // Field owners can update reports for their fields
      allow update: if request.auth != null && 
        get(/databases/$(database)/documents/fields/$(resource.data.field_id)).data.landowner_id == request.auth.uid;
      
      // Field owners can delete reports for their fields
      allow delete: if request.auth != null && 
        get(/databases/$(database)/documents/fields/$(resource.data.field_id)).data.landowner_id == request.auth.uid;
    }

  // Drivers Badge applications
  match /Drivers_Badge/{docId} {
    // Owner can create exactly once; docId must equal uid
    allow create: if request.auth != null &&
      docId == request.auth.uid &&
      request.resource.data.requestedBy == request.auth.uid &&
      !exists(/databases/$(database)/documents/Drivers_Badge/$(request.auth.uid));

    // Allow unauthenticated admin (PIN login) to view badge data
    allow read: if true;

    // Owner can update at most once every 30 days; officers/admins/system_admins can always update
    allow update: if request.auth != null && (
      get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role in ['sra', 'admin', 'system_admin'] ||
      (
        resource.data.requestedBy == request.auth.uid &&
        (
          resource.data.status == 'rejected' ||  // ✅ allow immediate resubmit after rejection
          !resource.data.lastEdit ||
          (request.time.toMillis() - resource.data.lastEdit.toMillis() >= 30 * 24 * 60 * 60 * 1000)
        )
      )
    );

    // Allow deletes by owner or staff. For full cascade on account deletion, use a Cloud Function.
    allow delete: if request.auth != null && (
      resource.data.requestedBy == request.auth.uid ||
      get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role in ['sra', 'admin', 'system_admin']
    );
  }

    
    // Allow admin dashboard to fetch Driver Badge requests
    match /Drivers_Badge/{docId} {
      // Allow read for your local dashboard (PIN-based admin)
      allow read: if true;
      // Keep write actions protected
      allow write: if request.auth != null;
    }
    
        // === System Admin Login Security Collections ===
    match /admin_pins/{pinId} {
      // Allow reading PINs for login (before authentication)
      allow read: if true;

      // Allow creating default admin PIN only when no users exist (setup stage)
      allow create: if request.auth != null || true;

      // System Admins can manage PINs
      allow update, delete: if request.auth != null &&
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'system_admin';
    }

    match /admin_security_logs/{logId} {
      // ✅ Allow login page to log failed attempts (unauthenticated)
      allow create: if true;

      // ✅ Allow unauthenticated read of limited recent logs (only specific fields)
      allow get, list: if request.auth == null;

      // ✅ Full access for authenticated system admins
      allow read, update, delete: if request.auth != null &&
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role in ['system_admin', 'super_admin', 'security_admin'];
    }

    // === Field Joins (per user, multiple fields under join_fields) ===
    match /field_joins/{userId} {
      // Allow requester and privileged roles to read container metadata
      allow read: if request.auth != null && (
        request.auth.uid == userId ||
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role in ['sra', 'admin', 'system_admin']
      );

      // Allow requester to create their join container doc
      allow create: if request.auth != null && request.auth.uid == userId;

      // Allow requester or sysadmin to update/delete their own doc
      allow update, delete: if request.auth != null && (
        request.auth.uid == userId ||
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'system_admin'
      );

      // Allow subcollection "join_fields" so each user can join multiple fields
      match /join_fields/{fieldId} {
        function isFieldOwner(uid) {
          return get(/databases/$(database)/documents/fields/$(fieldId)).data.userId == uid ||
                 get(/databases/$(database)/documents/fields/$(fieldId)).data.user_id == uid ||
                 get(/databases/$(database)/documents/fields/$(fieldId)).data.owner_uid == uid ||
                 get(/databases/$(database)/documents/fields/$(fieldId)).data.ownerId == uid ||
                 get(/databases/$(database)/documents/fields/$(fieldId)).data.landowner_id == uid ||
                 get(/databases/$(database)/documents/fields/$(fieldId)).data.registered_by == uid;
        }

        // Requester can manage their own join documents; field owners and privileged roles can read
        allow read: if request.auth != null && (
          request.auth.uid == userId ||
          isFieldOwner(request.auth.uid) ||
          get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role in ['sra', 'admin', 'system_admin']
        );

        allow create: if request.auth != null && request.auth.uid == userId;

        allow update, delete: if request.auth != null && (
          request.auth.uid == userId ||
          isFieldOwner(request.auth.uid) ||
          get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'system_admin'
        );
      }
    }

    // === Allow collectionGroup queries on join_fields ===
    match /{path=**}/join_fields/{fieldId} {
      // Allow authenticated users to query join_fields across all field_joins documents
      allow read: if request.auth != null;
    }

  }
}