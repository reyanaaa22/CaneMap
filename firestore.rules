rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Users can read their own data
    match /users/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }
    
    // Allow creation of users for SRA Officer registration
    match /users/{userId} {
      allow create: if request.auth != null || 
        (request.resource.data.role == 'sra_officer' && 
         request.resource.data.email != null && 
         request.resource.data.name != null);
    }
    
    // Allow creation of temp_passwords for user management
    match /temp_passwords/{tempId} {
      allow create, read, update, delete: if request.auth != null;
    }
    
    // Allow creation of notifications
    match /notifications/{notificationId} {
      allow create, read, update, delete: if request.auth != null;
    }
    
    // Allow creation of email_queue
    match /email_queue/{emailId} {
      allow create, read, update, delete: if request.auth != null;
    }
    
    // Fields access rules
    match /fields/{fieldId} {
      // Anyone authenticated can read fields
      allow read: if request.auth != null;
      
      // Only verified landowners can create fields
      allow create: if request.auth != null && 
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'landowner' &&
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.status == 'verified';
      
      // Only the field owner can update their fields
      allow update: if request.auth != null && 
        resource.data.landowner_id == request.auth.uid;
      
      // Only the field owner can delete their fields
      allow delete: if request.auth != null && 
        resource.data.landowner_id == request.auth.uid;
    }
    
    // Add this block inside your firestore.rules, e.g. after the users or fields rules
    match /field_applications/{docId} {
      allow create: if request.auth != null;
      allow read: if request.auth != null;
      allow update: if request.auth != null && (
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'sra_officer' ||
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin'
      );
    }
    // Nested fields within an application (users can have multiple fields)
    match /field_applications/{docId}/fields/{fieldId} {
      // Allow authenticated users and SRA/admins to read applications
      allow read: if request.auth != null;
      // Only SRA officers/admins can update review status under nested applications
      allow update: if request.auth != null && (
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role in ['sra_officer', 'admin']
      );
      // Owners can create their own nested field applications
      allow create: if request.auth != null && request.auth.uid == docId;
    }

    // Field workers (join requests) access rules
    match /field_workers/{requestId} {
      // Users can read their own requests
      allow read: if request.auth != null && 
        (resource.data.user_uid == request.auth.uid || 
         get(/databases/$(database)/documents/fields/$(resource.data.field_id)).data.landowner_id == request.auth.uid);
      
      // Users can create join requests for any field
      allow create: if request.auth != null && 
        request.resource.data.user_uid == request.auth.uid;
      
      // Only the field owner can update join requests (approve/reject)
      allow update: if request.auth != null && 
        get(/databases/$(database)/documents/fields/$(resource.data.field_id)).data.landowner_id == request.auth.uid;
      
      // Users can delete their own requests, field owners can delete requests for their fields
      allow delete: if request.auth != null && 
        (resource.data.user_uid == request.auth.uid || 
         get(/databases/$(database)/documents/fields/$(resource.data.field_id)).data.landowner_id == request.auth.uid);
    }
    
    // Task logs access rules
    match /task_logs/{logId} {
      // Field workers can read logs for fields they're approved to work on
      allow read: if request.auth != null && 
        (resource.data.user_uid == request.auth.uid || 
         get(/databases/$(database)/documents/fields/$(resource.data.field_id)).data.landowner_id == request.auth.uid);
      
      // Approved field workers can create task logs
      allow create: if request.auth != null && 
        request.resource.data.user_uid == request.auth.uid &&
        exists(/databases/$(database)/documents/field_workers/$(request.auth.uid + '_' + resource.data.field_id)) &&
        get(/databases/$(database)/documents/field_workers/$(request.auth.uid + '_' + resource.data.field_id)).data.status == 'approved';
      
      // Users can update their own task logs
      allow update: if request.auth != null && 
        resource.data.user_uid == request.auth.uid;
      
      // Users can delete their own task logs, field owners can delete logs for their fields
      allow delete: if request.auth != null && 
        (resource.data.user_uid == request.auth.uid || 
         get(/databases/$(database)/documents/fields/$(resource.data.field_id)).data.landowner_id == request.auth.uid);
    }
    
    // Reports access rules
    match /reports/{reportId} {
      // Field owners can read reports for their fields
      allow read: if request.auth != null && 
        get(/databases/$(database)/documents/fields/$(resource.data.field_id)).data.landowner_id == request.auth.uid;
      
      // Field owners can create reports for their fields
      allow create: if request.auth != null && 
        get(/databases/$(database)/documents/fields/$(request.resource.data.field_id)).data.landowner_id == request.auth.uid;
      
      // Field owners can update reports for their fields
      allow update: if request.auth != null && 
        get(/databases/$(database)/documents/fields/$(resource.data.field_id)).data.landowner_id == request.auth.uid;
      
      // Field owners can delete reports for their fields
      allow delete: if request.auth != null && 
        get(/databases/$(database)/documents/fields/$(resource.data.field_id)).data.landowner_id == request.auth.uid;
    }

    // Drivers Badge applications
    match /Drivers_Badge/{docId} {
      // Owner can create exactly once; docId must equal uid
      allow create: if request.auth != null &&
        docId == request.auth.uid &&
        request.resource.data.requestedBy == request.auth.uid &&
        !exists(/databases/$(database)/documents/Drivers_Badge/$(request.auth.uid));

      // Owner can read; officers/admins can read all
      allow read: if request.auth != null && (
        resource.data.requestedBy == request.auth.uid ||
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role in ['sra_officer', 'admin']
      );

      // Owner can update at most once every 30 days; officers/admins can always update
      allow update: if request.auth != null && (
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role in ['sra_officer', 'admin'] ||
        (
          resource.data.requestedBy == request.auth.uid &&
          (
            // Allow update if no lastEdit exists (first edit) or 30 days passed
            !resource.data.lastEdit ||
            (
              // Firestore rules: request.time is current server time
              request.time.toMillis() - resource.data.lastEdit.toMillis() >= 30 * 24 * 60 * 60 * 1000
            )
          )
        )
      );

      // Allow deletes by owner or staff. For full cascade on account deletion, use a Cloud Function.
      allow delete: if request.auth != null && (
        resource.data.requestedBy == request.auth.uid ||
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role in ['sra_officer', 'admin']
      );
    }
  }
}